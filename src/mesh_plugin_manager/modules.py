"""Module generation functions for scanning plugins and generating DynamicModules.cpp."""

import os
import re
import sys


def generate_dynamic_modules(project_dir, plugins, verbose=True):
    """
    Generate DynamicModules.cpp from plugin headers that contain #pragma MPM_MODULE.

    Args:
        project_dir: Root directory of the project
        plugins: List of plugin tuples from scan_plugins()
        verbose: Whether to print status messages

    Returns:
        bool: True if successful, False otherwise
    """
    # Path for generated file
    generated_dir = os.path.join(project_dir, "src", "mesh", "generated")
    cpp_file = os.path.join(generated_dir, "DynamicModules.cpp")

    # Ensure generated directory exists
    os.makedirs(generated_dir, exist_ok=True)

    # Collect module registrations from plugin headers
    module_registrations = []
    pragma_pattern = re.compile(r'#pragma\s+MPM_MODULE\s*\(\s*(\w+)(?:\s*,\s*(\w+))?\s*\)')

    for plugin_name, plugin_path, src_path, proto_files in plugins:
        # Scan all .h files in the plugin src directory
        if not os.path.isdir(src_path):
            continue

        for root, dirs, files in os.walk(src_path):
            # Skip hidden directories
            dirs[:] = [d for d in dirs if not d.startswith(".")]
            for file in files:
                if file.endswith(".h"):
                    header_path = os.path.join(root, file)
                    try:
                        with open(header_path, "r", encoding="utf-8") as f:
                            content = f.read()
                            # Search for pragma in the file
                            for match in pragma_pattern.finditer(content):
                                class_name = match.group(1)
                                variable_name = match.group(2) if match.group(2) else None
                                # Extract header filename (just the basename)
                                header_filename = file
                                module_registrations.append({
                                    "plugin_name": plugin_name,
                                    "class_name": class_name,
                                    "header_filename": header_filename,
                                    "variable_name": variable_name,
                                })
                                if verbose:
                                    var_info = f" -> {variable_name}" if variable_name else ""
                                    print(f"MPM: Found module {class_name} in {plugin_name}/{header_filename}{var_info}")
                    except Exception as e:
                        if verbose:
                            print(f"MPM: Warning: Failed to read {header_path}: {e}")

    # Sort by plugin name and class name for determinism
    module_registrations.sort(key=lambda x: (x["plugin_name"], x["class_name"]))

    # Generate the .cpp file
    try:
        with open(cpp_file, "w", encoding="utf-8") as f:
            f.write("// src/mesh/generated/DynamicModules.cpp (GENERATED - DO NOT EDIT)\n")
            f.write("// This file is auto-generated by MPM. Do not edit manually.\n\n")

            # Include DebugConfiguration.h for LOG_DEBUG
            f.write('#include "DebugConfiguration.h"\n')

            # Collect unique header includes
            header_includes = set()
            for reg in module_registrations:
                header_includes.add(reg["header_filename"])

            # Write includes
            if header_includes:
                f.write("\n")
            for header in sorted(header_includes):
                f.write(f'#include "{header}"\n')

            if header_includes:
                f.write("\n")

            # Write function implementation
            f.write("void init_dynamic_modules() {\n")

            if module_registrations:
                current_plugin = None
                for reg in module_registrations:
                    # Add comment when plugin changes
                    if reg["plugin_name"] != current_plugin:
                        if current_plugin is not None:
                            f.write("\n")
                        f.write(f'    // Plugin: {reg["plugin_name"]}\n')
                        current_plugin = reg["plugin_name"]

                    # Write LOG_DEBUG before instantiation
                    f.write(f'    LOG_DEBUG("Initializing module {reg["class_name"]} from plugin {reg["plugin_name"]}");\n')
                    
                    # Write instantiation
                    if reg["variable_name"]:
                        f.write(f'    {reg["variable_name"]} = new {reg["class_name"]}();\n')
                    else:
                        f.write(f'    new {reg["class_name"]}();\n')
            else:
                f.write("    // No plugins installed\n")

            f.write("}\n")

        if verbose:
            print(f"MPM: Generated DynamicModules.cpp with {len(module_registrations)} module(s)")
        return True

    except Exception as e:
        print(f"MPM: Error generating DynamicModules.cpp: {e}", file=sys.stderr)
        return False

